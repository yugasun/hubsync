name: Issue Sync

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: string

jobs:
  process-issue:
    name: Process Issue
    runs-on: ubuntu-latest
    steps:
      - name: Check authorization
        id: auth
        run: |
          IS_AUTHORIZED="false"
          ISSUE_NUMBER=""
          
          # Check if user is authorized or event is an issue event
          if [ "${{ github.actor }}" == "yugasun" ] || [ "${{ github.event_name }}" == "issues" ]; then
            IS_AUTHORIZED="true"
          fi
          
          # Get issue number based on event type
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
          else
            ISSUE_NUMBER="${{ github.event.issue.number }}"
          fi
          
          echo "is-authorized=$IS_AUTHORIZED" >> $GITHUB_OUTPUT
          echo "issue-number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
      
      - name: Post unauthorized message
        if: steps.auth.outputs.is-authorized == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.auth.outputs.issue-number }}', 10);
            if (isNaN(issueNumber)) {
              console.log('Invalid issue number, skipping comment');
              return;
            }
            
            const unauthorizedMessage = `
            ## ‚ö†Ô∏è Unauthorized Workflow Trigger

            Hi @${{ github.actor }}, thank you for your interest in HubSync!

            This workflow is restricted and can only be triggered by the repository owner (**@yugasun**). 
            
            ### üõ†Ô∏è Want to run your own instance of HubSync?
            
            1. **Fork this repository** to your GitHub account
            2. **Set up the following secrets** in your repository settings:
               - \`DOCKER_USERNAME\`: Your Docker Hub username
               - \`DOCKER_PASSWORD\`: Your Docker Hub password/token
               - \`DOCKER_NAMESPACE\`: Your Docker Hub namespace (optional)
               - \`DOCKER_REPOSITORY\`: Your Docker Hub repository (optional)
            3. **Enable GitHub Actions** in your forked repository
            
            Then you can use the workflow in your own repository with your credentials!
            
            ### üìù Need help?
            
            Feel free to open an issue on this repository for assistance.
            `;
            
            await github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: unauthorizedMessage
            }).catch(error => console.log(`Error posting comment: ${error.message}`));

      # Proceed only if authorized and issue meets criteria
      - name: Verify issue eligibility
        id: verify
        if: steps.auth.outputs.is-authorized == 'true'
        run: |
          IS_ELIGIBLE="false"
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            IS_ELIGIBLE="true"
          elif [ "${{ github.event_name }}" == "issues" ] && 
               ( ${{ contains(github.event.issue.labels.*.name, 'hubsync') }} || 
                 ${{ contains(github.event.issue.title, '[hubsync]') }} ); then
            IS_ELIGIBLE="true"
          fi
          
          echo "is-eligible=$IS_ELIGIBLE" >> $GITHUB_OUTPUT
      
      - name: Checkout code
        if: steps.verify.outputs.is-eligible == 'true'
        uses: actions/checkout@v4
      
      - name: Setup Golang
        if: steps.verify.outputs.is-eligible == 'true'
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true
      
      - name: Build HubSync
        if: steps.verify.outputs.is-eligible == 'true'
        run: make build
      
      - name: Get issue content
        id: issue-content
        if: steps.verify.outputs.is-eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.auth.outputs.issue-number }}', 10);
            if (isNaN(issueNumber)) {
              core.setFailed('Invalid issue number');
              return { body: '', number: 0 };
            }
            
            // For workflow_dispatch, fetch issue data
            if ('${{ github.event_name }}' === 'workflow_dispatch') {
              try {
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                return { body: issue.body || '', number: issue.number };
              } catch (error) {
                core.setFailed(`Failed to fetch issue: ${error.message}`);
                return { body: '', number: 0 };
              }
            } 
            // For issue events, use the event data directly
            else {
              // When using issue event, properly format body as a single line JSON string
              const issueBody = '${{ github.event.issue.body || "" }}'.replace(/\r?\n/g, ' ').trim();
              return { 
                body: issueBody,
                number: parseInt('${{ github.event.issue.number }}', 10) || 0
              };
            }
          result-encoding: string
      
      - name: Process issue body
        id: process
        if: steps.verify.outputs.is-eligible == 'true'
        run: |
          # Extract issue details
          ISSUE_BODY='${{ fromJson(steps.issue-content.outputs.result).body }}'
          ISSUE_NUMBER='${{ fromJson(steps.issue-content.outputs.result).number }}'
          
          echo "issue-number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          
          # Extract and validate JSON content
          echo "Extracting JSON content from issue body..."
          CONTENT=$(echo "$ISSUE_BODY" | perl -0777 -ne 'print $& if /\{(?:[^{}]|(?0))*\}/' || echo '')
          
          # Handle missing or invalid JSON
          if [ -z "$CONTENT" ] || ! echo "$CONTENT" | jq . >/dev/null 2>&1 || ! echo "$CONTENT" | jq -e '.hubsync' >/dev/null 2>&1; then
            echo "content={\"hubsync\":[]}" >> $GITHUB_OUTPUT
            echo "status=invalid" >> $GITHUB_OUTPUT
            echo "warning::Invalid or missing JSON content in issue body" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # Valid JSON with hubsync array
          ESCAPED_CONTENT=$(echo "$CONTENT" | jq -c . | sed 's/%/%25/g' | sed 's/\n/%0A/g' | sed 's/\r/%0D/g')
          echo "content=$ESCAPED_CONTENT" >> $GITHUB_OUTPUT
          echo "status=valid" >> $GITHUB_OUTPUT
          
          # Preview what will be synced
          echo "Images to sync:"
          echo "$CONTENT" | jq -r '.hubsync[]' 2>/dev/null
      
      - name: Run HubSync
        id: sync
        if: steps.verify.outputs.is-eligible == 'true' && steps.process.outputs.status == 'valid'
        run: |
          echo "Starting Docker Hub synchronization..."
          # Using echo directly without temp file improves performance
          ./bin/hubsync \
            --username=${{ secrets.DOCKER_USERNAME }} \
            --password=${{ secrets.DOCKER_PASSWORD }} \
            --repository=${{ secrets.DOCKER_REPOSITORY || '' }} \
            --namespace=${{ secrets.DOCKER_NAMESPACE || 'yugasun' }} \
            --content='${{ steps.process.outputs.content }}'
        continue-on-error: true
      
      - name: Post issue update
        if: steps.verify.outputs.is-eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueNumber = parseInt('${{ steps.process.outputs.issue-number }}', 10);
            const syncOutcome = '${{ steps.sync.outcome }}';
            const processStatus = '${{ steps.process.outputs.status }}';
            
            // For invalid JSON or failed sync
            if (processStatus === 'invalid' || syncOutcome === 'failure') {
              // Add failure label
              await github.rest.issues.addLabels({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['failure']
              }).catch(error => console.log('Error adding labels:', error));
              
              // Get error details
              let errorLog = '';
              try {
                if (fs.existsSync('output.log')) {
                  errorLog = fs.readFileSync('output.log', 'utf8');
                }
              } catch (error) {
                errorLog = 'Error details unavailable';
              }
              
              // Post failure comment
              const errorMessage = [
                '## ‚ùå Image Sync Failed',
                '',
                'Please check the format of your request and try again.',
                '',
                '### Troubleshooting',
                '- Make sure your JSON is valid and follows the required format: `{ "hubsync": ["image1", "image2"] }`',
                '- Check that the Docker images specified exist and are accessible',
                '- Verify your credentials have the necessary permissions',
                '',
                '### Error Details',
                '```',
                errorLog,
                '```',
                '',
                '### Need help?',
                'Feel free to update this issue with a corrected format.'
              ].join('\n');
              
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorMessage
              });
            } 
            // For successful sync
            else if (syncOutcome === 'success') {
              // Add success labels
              await github.rest.issues.addLabels({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['success', 'synchronized']
              }).catch(error => console.log('Error adding labels:', error));
              
              // Get output information
              let output = 'No output file generated, but operation completed successfully.';
              try {
                if (fs.existsSync('output.log')) {
                  output = fs.readFileSync('output.log', 'utf8').trim();
                }
              } catch (error) {
                // Keep default message
              }
              
              // Get image count safely
              let imageCount = 0;
              try {
                const contentRaw = '${{ steps.process.outputs.content }}';
                let contentObj;
                
                // Simplified parsing
                try {
                  contentObj = JSON.parse(contentRaw.replace(/^["']|["']$/g, ''));
                } catch (e) {
                  try {
                    contentObj = JSON.parse(contentRaw.replace(/\\"/g, '"'));
                  } catch (e2) {
                    console.log('Failed to parse content JSON:', e2);
                    contentObj = { hubsync: [] };
                  }
                }
                
                imageCount = contentObj && contentObj.hubsync && Array.isArray(contentObj.hubsync) 
                  ? contentObj.hubsync.length 
                  : 0;
              } catch (e) {
                console.log('Error parsing content:', e);
                imageCount = "some";
              }
              
              // Post success comment
              const successMessage = [
                '## ‚úÖ Image Sync Completed Successfully!',
                '',
                `Successfully synchronized **${imageCount}** Docker image(s).`,
                '',
                '### Pull Commands',
                '```bash',
                output,
                '```'
              ].join('\n');
              
              await github.rest.issues.createComment({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: successMessage
              });
              
              // Close issue
              await github.rest.issues.update({
                issue_number: issueNumber,
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                state_reason: 'completed'
              });
            }